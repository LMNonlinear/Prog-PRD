%load frey_rawface.mat  %20*28 images

load observation.mat
num_observations
N=num_observations;

D=length(obs{1}.data)
imgwidth= obs{1}.imgwidth;
imglen=107;

data=zeros(N,D);
for i=1:N
    size(obs{i}.data)
    data(i,:)=obs{i}.data(1,1:D);
end
Y=data;

close all;
figure(1)
for i=1:num_observations
im=Y(i,:);
im2=reshape(im,imgwidth,imglen);

imshow(im2, [])
pause(0.01);
end

pause

% Fix seeds
randn('seed', 1e5);
rand('seed', 1e5);






% Extract data dimensions and set IVM active set size
numData = size(Y, 1)
dataDim = size(Y, 2)
numActive = 30;
extIters = 10  %15;

% Don't centre the data so that when there is no Brendan there is no Brendan.
meanData = zeros(1, dataDim); %mean(Y);
Y = Y  - repmat(meanData, size(Y, 1), 1);

% Initialise X with PCA
[v, u] = pca(Y);
v(find(v<0))=0;
X = Y*u(:, 1:2)*diag(1./sqrt(v(1:2)));

% Initialise theta
theta(1) = 1;
theta(2) = 1;
theta(3) = 1;

if 1
% Options for optimisation in latent space
options = foptions;
options(1) = 0;
options(9) = 0;
options(14) = 100;

% options for kernel optimisation
optionsKernel = foptions;
optionsKernel(1) = 0;
optionsKernel(9) = 0;
optionsKernel(14) = 100;

else

options = optimset('GradObj','on','MaxIter',100,'Display','iter');
optionsKernel = options;

end

% Fit the GP latent variable model
[X, theta, activeSet] = gplvmfit(X, Y, theta, numActive, optionsKernel, ...
		      options, extIters)
  
% compute the kernel from results
[K, invK] = computeKernel(X(activeSet, :), theta);

% Visualise the results
gplvmvisualise(X, Y, invK, theta, [], meanData, activeSet, 'imageVisualise', ...
	       'imageModify', [imgwidth,imglen]);

if 0
my_visualize(X, Y, invK, theta, [], meanData, activeSet, 'imageVisualise', 'imageModify', [20 28]);
end

save gplvmBrendan.mat X theta activeSet
